import requests
from urllib.parse import urljoin, urlparse
import re
import concurrent.futures
import ssl
import socket
from bs4 import BeautifulSoup
import logging
import argparse
import whois
import dns.resolver
from concurrent.futures import ThreadPoolExecutor, as_completed
from requests.exceptions import RequestException
import json
import subprocess
import os

class AdvancedPentestTool:
    """
    An advanced penetration testing tool that performs various security checks
    on a target URL or IP address. The tool checks for vulnerabilities such as
    open ports, subdomains, HTTPS, security headers, sensitive files, and more.
    """
    def __init__(self, target, output_file=None, verbosity=1):
        """
        Initializes the AdvancedPentestTool with the target URL or IP, output file path,
        and verbosity level.

        :param target: The target URL or IP address to test.
        :param output_file: Path to the file where the vulnerability report will be saved.
        :param verbosity: Verbosity level for logging. 1 for INFO, 0 for ERROR.
        """
        self.target = target
        self.base_url = f"http://{target}" if not target.startswith(('http://', 'https://')) else target
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'PentestTool/2.0'})
        self.vulnerabilities = []
        self.output_file = output_file
        self.verbosity = verbosity
        logging.basicConfig(level=logging.INFO if verbosity > 0 else logging.ERROR,
                            format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)

    def run_tests(self):
        """
        Runs all the defined tests to perform security checks on the target.
        Each test is executed in parallel using a thread pool.
        """
        self.logger.info(f"Starting advanced pentest for {self.target}")
        
        tests = [
            self.gather_information,
            self.scan_ports,
            self.enumerate_subdomains,
            self.check_https,
            self.check_security_headers,
            self.check_sensitive_files,
            self.check_xss_vulnerability,
            self.check_sql_injection,
            self.check_ssl_vulnerabilities,
            self.check_open_ports,
            self.check_cookie_security,
            self.check_directory_listing,
            self.check_server_version,
            self.check_cors_policy,
            self.check_form_inputs,
            self.check_clickjacking,
            self.check_csrf,
            self.brute_force_directories,
            self.check_outdated_software,
        ]

        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(test) for test in tests]
            for future in as_completed(futures):
                try:
                    future.result()
                except Exception as e:
                    self.logger.error(f"An error occurred during testing: {str(e)}")

        self.logger.info("Advanced pentest completed")
        self.report_vulnerabilities()

    def gather_information(self):
        """
        Gathers basic information about the target, including domain, IP address,
        WHOIS information, and MX records.
        """
        self.logger.info("Gathering information about the target...")
        try:
            domain = urlparse(self.base_url).netloc
            ip = socket.gethostbyname(domain)
            self.logger.info(f"Domain: {domain}")
            self.logger.info(f"IP: {ip}")
            
            try:
                import whois
                w = whois.whois(domain)
                self.logger.info(f"Registrar: {w.registrar}")
                self.logger.info(f"Creation Date: {w.creation_date}")
                self.logger.info(f"Expiration Date: {w.expiration_date}")
            except ImportError:
                self.logger.warning("python-whois not installed. Skipping WHOIS information gathering.")
            
            try:
                import dns.resolver
                answers = dns.resolver.resolve(domain, 'MX')
                mx_records = [rdata.exchange.to_text() for rdata in answers]
                self.logger.info(f"MX Records: {', '.join(mx_records)}")
            except ImportError:
                self.logger.warning("dnspython not installed. Skipping DNS information gathering.")
        except Exception as e:
            self.logger.error(f"Error gathering information: {str(e)}")

    def scan_ports(self):
        """
        Scans common ports on the target to check if they are open and identifies
        the services running on those ports.
        """
        self.logger.info("Scanning ports...")
        common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 465, 587, 993, 995, 3306, 3389, 5432, 8080, 8443]
        open_ports = []
        hostname = urlparse(self.base_url).netloc
        for port in common_ports:
            try:
                with socket.create_connection((hostname, port), timeout=1):
                    service = socket.getservbyport(port)
                    open_ports.append(f"{port}/{service}")
                    self.logger.info(f"Port {port} is open - {service}")
            except (socket.timeout, ConnectionRefusedError):
                pass
            except Exception as e:
                self.logger.error(f"Error checking port {port}: {str(e)}")
        if open_ports:
            self.add_vulnerability(f"Open ports detected: {', '.join(open_ports)}", "Medium")

    def enumerate_subdomains(self):
        """
        Attempts to identify valid subdomains of the target by testing a list of common subdomains.
        """
        self.logger.info("Enumerating subdomains...")
        domain = urlparse(self.base_url).netloc
        subdomains = ['www', 'mail', 'ftp', 'localhost', 'webmail', 'smtp', 'pop', 'ns1', 'webdisk', 'ns2', 'cpanel', 'whm', 'autodiscover', 'autoconfig', 'm', 'imap', 'test', 'ns', 'blog', 'pop3', 'dev', 'www2', 'admin', 'forum', 'news', 'vpn', 'ns3', 'mail2', 'new', 'mysql', 'old', 'lists', 'support', 'mobile', 'mx', 'static', 'docs', 'beta', 'shop', 'sql', 'secure', 'demo', 'cp', 'calendar', 'wiki', 'web', 'media', 'email', 'images', 'img', 'www1', 'intranet', 'portal', 'video', 'sip', 'dns2', 'api', 'cdn', 'stats', 'dns1', 'ns4', 'www3', 'dns', 'search', 'staging', 'server', 'mx1', 'chat', 'wap', 'my', 'svn', 'mail1', 'sites', 'proxy', 'ads', 'host', 'crm', 'cms', 'backup', 'mx2', 'lyncdiscover', 'info', 'apps', 'download', 'remote', 'db', 'forums', 'store', 'relay', 'files', 'newsletter', 'app', 'live', 'owa', 'en', 'start', 'sms', 'office', 'exchange', 'ipv4']
        
        valid_subdomains = []
        with ThreadPoolExecutor(max_workers=20) as executor:
            futures = [executor.submit(self.check_subdomain, f"{sub}.{domain}") for sub in subdomains]
            for future in as_completed(futures):
                result = future.result()
                if result:
                    valid_subdomains.append(result)
                    self.logger.info(f"Found subdomain: {result}")
        
        if valid_subdomains:
            self.add_vulnerability(f"Subdomains found: {', '.join(valid_subdomains)}", "Info")

    def check_subdomain(self, subdomain):
        """
        Checks if a given subdomain resolves to an IP address.

        :param subdomain: The subdomain to check.
        :return: The subdomain if it resolves, otherwise None.
        """
        try:
            socket.gethostbyname(subdomain)
            return subdomain
        except socket.gaierror:
            return None

    def check_https(self):
        """
        Checks if the target uses HTTPS.
        """
        if not self.base_url.startswith("https://"):
            self.add_vulnerability("Site is not using HTTPS", "High")

    def check_security_headers(self):
        """
        Checks for the presence of important security headers in the HTTP response.
        """
        try:
            response = self.session.get(self.base_url)
            headers = response.headers
            important_headers = {
                'Strict-Transport-Security': 'HSTS not implemented',
                'X-Frame-Options': 'Clickjacking protection not implemented',
                'X-XSS-Protection': 'XSS protection not implemented',
                'X-Content-Type-Options': 'MIME type sniffing prevention not implemented',
                'Content-Security-Policy': 'Content Security Policy not implemented',
                'Referrer-Policy': 'Referrer Policy not implemented',
                'Permissions-Policy': 'Permissions Policy not implemented'
            }
            for header, message in important_headers.items():
                if header not in headers:
                    self.add_vulnerability(message, "Medium")
        except RequestException as e:
            self.logger.error(f"Error checking security headers: {str(e)}")

    def check_sensitive_files(self):
        """
        Checks for the presence of common sensitive files on the server.
        """
        sensitive_files = ['/robots.txt', '/sitemap.xml', '/admin/', '/config.php', '/.env', '/.git/', '/backup/']
        for file in sensitive_files:
            url = urljoin(self.base_url, file)
            try:
                response = self.session.get(url)
                if response.status_code == 200:
                    self.add_vulnerability(f"Sensitive file found: {file}", "High")
            except RequestException as e:
                self.logger.error(f"Error checking sensitive files: {str(e)}")

    def check_xss_vulnerability(self):
        """
        Checks for Cross-Site Scripting (XSS) vulnerabilities by injecting a script payload.
        """
        payload = "<script>alert('XSS')</script>"
        test_url = urljoin(self.base_url, f"?q={payload}")
        try:
            response = self.session.get(test_url)
            if payload in response.text:
                self.add_vulnerability("Possible XSS vulnerability detected", "High")
        except RequestException as e:
            self.logger.error(f"Error checking XSS vulnerability: {str(e)}")

    def check_sql_injection(self):
        """
        Checks for SQL Injection vulnerabilities by injecting a payload.
        """
        payload = "' OR '1'='1"
        test_url = urljoin(self.base_url, f"?id={payload}")
        try:
            response = self.session.get(test_url)
            if "sql" in response.text.lower():
                self.add_vulnerability("Possible SQL Injection vulnerability detected", "High")
        except RequestException as e:
            self.logger.error(f"Error checking SQL Injection: {str(e)}")

    def check_ssl_vulnerabilities(self):
        """
        Checks for SSL/TLS vulnerabilities, including outdated versions and weak ciphers.
        """
        try:
            context = ssl.create_default_context()
            with socket.create_connection((urlparse(self.base_url).hostname, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=urlparse(self.base_url).hostname) as ssock:
                    cipher = ssock.cipher()
                    self.logger.info(f"SSL/TLS Cipher: {cipher}")
                    if 'TLSv1.0' in cipher or 'TLSv1.1' in cipher:
                        self.add_vulnerability("Outdated SSL/TLS version detected", "High")
        except Exception as e:
            self.logger.error(f"Error checking SSL/TLS vulnerabilities: {str(e)}")

    def check_open_ports(self):
        """
        Checks for open ports on the target using a simple socket connection.
        """
        # The method is similar to scan_ports but should be customized if needed.
        pass

    def check_cookie_security(self):
        """
        Verifies the security attributes of cookies.
        """
        try:
            response = self.session.get(self.base_url)
            cookies = response.cookies
            for cookie in cookies:
                if not cookie.secure:
                    self.add_vulnerability("Insecure cookie detected", "Medium")
                if not cookie.httpOnly:
                    self.add_vulnerability("Cookie without HttpOnly flag detected", "Medium")
                if cookie.sameSite != 'Strict':
                    self.add_vulnerability("Cookie without SameSite=Strict flag detected", "Medium")
        except RequestException as e:
            self.logger.error(f"Error checking cookie security: {str(e)}")

    def check_directory_listing(self):
        """
        Checks if directory listing is enabled for common directories.
        """
        directories = ['/', '/admin/', '/cgi-bin/', '/test/']
        for directory in directories:
            url = urljoin(self.base_url, directory)
            try:
                response = self.session.get(url)
                if "Index of" in response.text:
                    self.add_vulnerability(f"Directory listing enabled: {directory}", "Medium")
            except RequestException as e:
                self.logger.error(f"Error checking directory listing: {str(e)}")

    def check_server_version(self):
        """
        Detects server version information from HTTP headers.
        """
        try:
            response = self.session.get(self.base_url)
            server_header = response.headers.get('Server', '')
            if server_header:
                self.add_vulnerability(f"Server version detected: {server_header}", "Low")
        except RequestException as e:
            self.logger.error(f"Error checking server version: {str(e)}")

    def check_cors_policy(self):
        """
        Examines Cross-Origin Resource Sharing (CORS) policy for potential issues.
        """
        try:
            response = self.session.get(self.base_url)
            cors_headers = ['Access-Control-Allow-Origin', 'Access-Control-Allow-Methods', 'Access-Control-Allow-Headers']
            for header in cors_headers:
                if header not in response.headers:
                    self.add_vulnerability(f"CORS header '{header}' missing", "Medium")
        except RequestException as e:
            self.logger.error(f"Error checking CORS policy: {str(e)}")

    def check_form_inputs(self):
        """
        Checks form input fields for security issues.
        """
        try:
            response = self.session.get(self.base_url)
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')
            for form in forms:
                inputs = form.find_all('input')
                for input_tag in inputs:
                    if input_tag.get('type') in ['text', 'password']:
                        self.add_vulnerability(f"Form input field detected: {input_tag.get('name')}", "Medium")
        except RequestException as e:
            self.logger.error(f"Error checking form inputs: {str(e)}")

    def check_clickjacking(self):
        """
        Tests if the target implements clickjacking protection.
        """
        try:
            response = self.session.get(self.base_url)
            if 'X-Frame-Options' not in response.headers:
                self.add_vulnerability("Clickjacking protection not implemented", "High")
        except RequestException as e:
            self.logger.error(f"Error checking clickjacking protection: {str(e)}")

    def check_csrf(self):
        """
        Checks for Cross-Site Request Forgery (CSRF) protection in forms.
        """
        try:
            response = self.session.get(self.base_url)
            if 'csrf' not in response.text.lower():
                self.add_vulnerability("CSRF protection not implemented", "High")
        except RequestException as e:
            self.logger.error(f"Error checking CSRF protection: {str(e)}")

    def brute_force_directories(self):
        """
        Attempts to find hidden directories by brute force.
        """
        directories = ['admin', 'login', 'private', 'hidden', 'uploads', 'data']
        for directory in directories:
            url = urljoin(self.base_url, directory)
            try:
                response = self.session.get(url)
                if response.status_code == 200:
                    self.add_vulnerability(f"Brute-forced directory found: {directory}", "Medium")
            except RequestException as e:
                self.logger.error(f"Error brute-forcing directories: {str(e)}")

    def check_outdated_software(self):
        """
        Detects outdated versions of software like Apache, Nginx, and PHP.
        """
        try:
            response = self.session.get(self.base_url)
            server_header = response.headers.get('Server', '')
            if any(version in server_header for version in ['Apache', 'Nginx', 'PHP']):
                self.add_vulnerability(f"Outdated software detected: {server_header}", "High")
        except RequestException as e:
            self.logger.error(f"Error checking outdated software: {str(e)}")

    def add_vulnerability(self, description, severity):
        """
        Adds a detected vulnerability to the list.

        :param description: Description of the vulnerability.
        :param severity: Severity level of the vulnerability.
        """
        self.vulnerabilities.append({'description': description, 'severity': severity})

    def report_vulnerabilities(self):
        """
        Logs and saves detected vulnerabilities to a file in JSON format.
        """
        if self.output_file:
            with open(self.output_file, 'w') as f:
                json.dump(self.vulnerabilities, f, indent=4)
        self.logger.info(f"Vulnerabilities report saved to {self.output_file}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Advanced Pentest Tool")
    parser.add_argument("target", help="The target URL or IP address")
    parser.add_argument("-o", "--output", help="Path to the output file for the report")
    parser.add_argument("-v", "--verbosity", action="count", default=1, help="Increase verbosity level")
    args = parser.parse_args()

    tool = AdvancedPentestTool(args.target, args.output, args.verbosity)
    tool.run_tests()
